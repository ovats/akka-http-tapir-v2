package com.demo.endpoints

import com.demo.ServiceResponse
import com.demo.domain.Contact
import com.demo.endpoints.ContactsEndpoints._
import com.typesafe.scalalogging.LazyLogging
import io.circe.generic.auto._
import sttp.model.StatusCode
import sttp.tapir.generic.auto._
import sttp.tapir.json.circe.jsonBody
import sttp.tapir.{path, _}

object ContactsEndpoints {

  private val sampleContact =
    Contact(fullName = "John Doe", telephone = "555-5555", email = "mail@mail.com", country = "US")

  private val contactNotFound      = ServiceResponse(status = "error", description = "Contact not found")
  private val contactAlreadyExists = ServiceResponse(status = "error", description = "Contact already exists")
  private val internalError        = ServiceResponse(status = "error", description = "Error when [action]")
}

class ContactsEndpoints() extends LazyLogging {

  private val tag          = "Contacts"
  private val email        = path[String]("email")
  private val countryParam = query[Option[String]]("country")

  /**
   *  Definition of Endpoint[I, E, O, -R]:
   *
   *    (input: EndpointInput[I], errorOutput: EndpointOutput[E], output: EndpointOutput[O], info: EndpointInfo)
   *      I Input parameter types.
   *      E Error output parameter types.
   *      O Output parameter types.
   *      R The capabilities that are required by this endpoint's inputs/outputs.
   *        This might be `Any` (no requirements)
   */

  private val baseEndpoint = endpoint
    .tag(tag)
    .in("contacts")

  /**
   * Endpoint [
   *  I: Option[String]: optional country for filtering
   *  E: (StatusCode, ServiceResponse): response when error
   *  O: Seq[Contact]: response if no error, list of contacts
   *  R:
   * ]
   */
  val getAllContactsEndpoint: Endpoint[Option[String], ServiceResponse, Seq[Contact], Any] =
    baseEndpoint.get
      .summary("Use this endpoint to get the list of all contacts")
      .description("Get the list of all contacts")
      .in(countryParam.description("Country to filter out"))
      .out(
        jsonBody[Seq[Contact]]
          .description("List of contacts retrieved")
          .example(List(sampleContact))
      )
      .errorOut(
        oneOf[ServiceResponse](
          oneOfMapping(StatusCode.InternalServerError, jsonBody[ServiceResponse].example(internalError))
        )
      )

  /**
   * Endpoint [
   *  I: (Option[String],Contact): header and contact to add
   *  E: (StatusCode, ServiceResponse): response when error
   *  O: Contact: response if no error, contact added
   *  R:
   * ]
   */
  val addContactEndpoint: Endpoint[(Option[String], Contact), ServiceResponse, Contact, Any] =
    baseEndpoint.post
      .description("Add a new contact")
      .summary("Use this endpoint to add a Contact")
      .in(header[Option[String]]("Postman-Token").description("Automatically generated by Postman"))
      .in(
        jsonBody[Contact]
          .example(sampleContact)
          .description("Contact to add")
      )
      .out(
        jsonBody[Contact]
          .example(sampleContact)
          .description("Contact added")
      )
      .errorOut(
        oneOf[ServiceResponse](
          oneOfMapping(StatusCode.Conflict, jsonBody[ServiceResponse].example(contactAlreadyExists)),
          oneOfMapping(StatusCode.InternalServerError, jsonBody[ServiceResponse].example(internalError)),
        )
      )

  val getContactEndpoint: Endpoint[String, ServiceResponse, Contact, Any] = {
    baseEndpoint.get
      .summary("Use this endpoint to get a contact")
      .description("Get a contact")
      .in(
        email
          .example(sampleContact.email)
          .description("Email of the contact to search for")
      )
      .out(
        jsonBody[Contact]
          .example(sampleContact)
          .description("Contact found")
      )
      .errorOut(
        oneOf[ServiceResponse](
          oneOfMapping(StatusCode.NotFound, jsonBody[ServiceResponse].example(contactNotFound)),
          oneOfMapping(StatusCode.InternalServerError, jsonBody[ServiceResponse].example(internalError)),
        )
      )
  }

  val updateContactEndpoint: Endpoint[Contact, ServiceResponse, Contact, Any] = {
    baseEndpoint.put
      .summary("Use this endpoint to update a contact")
      .description("Update a contact")
      .in(
        jsonBody[Contact]
          .example(sampleContact)
          .description("Contact to update")
      )
      .out(
        jsonBody[Contact]
          .example(sampleContact)
          .description("Contact updated")
      )
      .errorOut(
        oneOf[ServiceResponse](
          oneOfMapping(StatusCode.NotFound, jsonBody[ServiceResponse].example(contactNotFound)),
          oneOfMapping(StatusCode.InternalServerError, jsonBody[ServiceResponse].example(internalError)),
        )
      )
  }

  val deleteContactEndpoint: Endpoint[String, ServiceResponse, Unit, Any] = {
    baseEndpoint.delete
      .summary("Use this endpoint to delete a contact")
      .description("Delete a contact")
      .in(
        path[String]("email")
          .example(sampleContact.email)
          .description("Email of the contact to delete")
      )
      .out(statusCode(StatusCode.NoContent))
      .errorOut(
        oneOf[ServiceResponse](
          oneOfMapping(StatusCode.NotFound, jsonBody[ServiceResponse].example(contactNotFound)),
          oneOfMapping(StatusCode.InternalServerError, jsonBody[ServiceResponse].example(internalError)),
        )
      )
  }

  val allEndpoints: Iterable[Endpoint[_, _, _, _]] =
    Seq(
      getAllContactsEndpoint,
      addContactEndpoint,
      getContactEndpoint,
      updateContactEndpoint,
      deleteContactEndpoint,
    )

}
